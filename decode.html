<script>

function testDecode(filename) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', filename, true);
  xhr.responseType = "arraybuffer";
  xhr.onload = function() {

  var text = document.createTextNode("Original audio: ");
  var audio = document.createElement("audio");
  audio.src = filename;
  audio.controls = true;
  var text2 = document.createTextNode("Decoded audio: ");
  document.body.appendChild(text);
  document.body.appendChild(audio);
  document.body.appendChild(document.createElement("br"));
  document.body.appendChild(text2);

  try {
    var cx = new AudioContext() ;
  } catch (ex) {
    var cx = new webkitAudioContext();
  }
  var buf = new ArrayBuffer(xhr.response.length);
  cx.decodeAudioData(xhr.response, function(x) {
/*
    var pre = document.querySelector("pre");
    pre.textContent += "Sample rate: " + x.sampleRate + ", length: " + x.length +
                       ", duration: " + x.duration + ", channels: " + x.numberOfChannels;
    for (var i = 0; i < x.numberOfChannels; ++i) {
      var array = x.getChannelData(i);
      var str = "\n\n\n\nContents of channel " + (i + 1) + ":\n\n";
      for (var j = 0; j < array.length; ++j) {
        str += array[j] + "\n";
      }
      pre.textContent += str;
    }
*/
    var wave = createWaveFileData(x);
    var blob = new Blob([wave], {type: "audio/wave"});
    blob.type = "audio/wave";
    var url = URL.createObjectURL(blob);
    var audio = document.createElement("audio");
    document.body.appendChild(audio);
    audio.src=url;
    audio.controls = true;
    document.body.appendChild(document.createElement("br"));

    }, function() {
    alert('failure');
  });

  };
  xhr.send();

}


function writeString(s, a, offset) {
    for (var i = 0; i < s.length; ++i) {
        a[offset + i] = s.charCodeAt(i);
    }
}

function writeInt16(n, a, offset) {
    n = Math.floor(n);
    
    var b1 = n & 255;
    var b2 = (n >> 8) & 255;

    a[offset + 0] = b1;
    a[offset + 1] = b2;
}

function writeInt32(n, a, offset) {
    n = Math.floor(n);
    var b1 = n & 255;
    var b2 = (n >> 8) & 255;
    var b3 = (n >> 16) & 255;
    var b4 = (n >> 24) & 255;

    a[offset + 0] = b1;
    a[offset + 1] = b2;
    a[offset + 2] = b3;
    a[offset + 3] = b4;
}

function writeAudioBuffer(audioBuffer, a, offset) {
    var n = audioBuffer.length;
    var channels = audioBuffer.numberOfChannels;
    
    for (var i = 0; i < n; ++i) {
        for (var k = 0; k < channels; ++k) {
            var buffer = audioBuffer.getChannelData(k);
            var sample = buffer[i] * 32768.0;

            // Clip samples to the limitations of 16-bit.
            // If we don't do this then we'll get nasty wrap-around distortion.
            if (sample < -32768)
                sample = -32768;
            if (sample > 32767)
                sample = 32767;

            writeInt16(sample, a, offset);
            offset += 2;
        }
    }
}

function createWaveFileData(audioBuffer) {
    var frameLength = audioBuffer.length;
    var numberOfChannels = audioBuffer.numberOfChannels;
    var sampleRate = audioBuffer.sampleRate;
    var bitsPerSample = 16;
    var byteRate = sampleRate * numberOfChannels * bitsPerSample/8;
    var blockAlign = numberOfChannels * bitsPerSample/8;
    var wavDataByteLength = frameLength * numberOfChannels * 2; // 16-bit audio
    var headerByteLength = 44;
    var totalLength = headerByteLength + wavDataByteLength;

    var waveFileData = new Uint8Array(totalLength);
    
    var subChunk1Size = 16; // for linear PCM
    var subChunk2Size = wavDataByteLength;
    var chunkSize = 4 + (8 + subChunk1Size) + (8 + subChunk2Size);

    writeString("RIFF", waveFileData, 0);
    writeInt32(chunkSize, waveFileData, 4);
    writeString("WAVE", waveFileData, 8);
    writeString("fmt ", waveFileData, 12);
    
    writeInt32(subChunk1Size, waveFileData, 16);      // SubChunk1Size (4)
    writeInt16(1, waveFileData, 20);                  // AudioFormat (2)
    writeInt16(numberOfChannels, waveFileData, 22);   // NumChannels (2)
    writeInt32(sampleRate, waveFileData, 24);         // SampleRate (4)
    writeInt32(byteRate, waveFileData, 28);           // ByteRate (4)
    writeInt16(blockAlign, waveFileData, 32);         // BlockAlign (2)
    writeInt32(bitsPerSample, waveFileData, 34);      // BitsPerSample (4)
                                                      
    writeString("data", waveFileData, 36);            
    writeInt32(subChunk2Size, waveFileData, 40);      // SubChunk2Size (4)
    
    // Write actual audio data starting at offset 44.
    writeAudioBuffer(audioBuffer, waveFileData, 44);
    
    return waveFileData;
}


testDecode('ting3.ogg?');
//testDecode('small-shot.ogg');
//testDecode('audio.ogv');

</script>
<pre></pre>

